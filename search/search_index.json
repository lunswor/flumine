{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"fl\u016bmine Betfair trading framework with a focus on: simplicity modular pythonic rock-solid safe Support for market, order and custom streaming data. join slack group Currently tested on Python 3.5, 3.6, 3.7 and 3.8. installation $ pip install flumine flumine requires Python 3.5+ setup Get started... import betfairlightweight from flumine import Flumine , clients trading = betfairlightweight . APIClient ( \"username\" ) client = clients . BetfairClient ( trading ) framework = Flumine ( client = client , ) Example strategy: from flumine import BaseStrategy from flumine.order.trade import Trade from flumine.order.order import LimitOrder , OrderStatus from flumine.markets.market import Market from betfairlightweight.filters import streaming_market_filter from betfairlightweight.resources import MarketBook class ExampleStrategy ( BaseStrategy ): def start ( self ) -> None : print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market : Market , market_book : MarketBook ) -> bool : # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market : Market , market_book : MarketBook ) -> None : # process marketBook object for runner in market_book . runners : if runner . status == \"ACTIVE\" and runner . last_price_traded < 1.5 : trade = Trade ( market_id = market_book . market_id , selection_id = runner . selection_id , handicap = runner . handicap , strategy = self , ) order = trade . create_order ( side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) self . place_order ( market , order ) def process_orders ( self , market : Market , orders : list ) -> None : for order in orders : if order . status == OrderStatus . EXECUTABLE : if order . size_remaining == 2.00 : self . cancel_order ( order , 0.02 ) # reduce size to 1.98 if order . order_type . persistence_type == \"LAPSE\" : self . update_order ( order , \"PERSIST\" ) if order . size_remaining > 0 : self . replace_order ( order , 1.02 ) # move strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ) ) framework . add_strategy ( strategy ) Run framework: framework . run () Danger By default flumine will try and prevent coding errors which result in flash crashes and burnt fingers but use at your own risk as per the MIT license. Recommendation is not to remove the trading controls and carry out extensive testing before executing on live markets, even then only use new strategies on an account with a small balance (transfer balance to games wallet). Features Streaming Multiple strategies Order execution Back testing (in development) Paper trading (on roadmap) Analytics (in development) Scores / RaceCard / InPlayService (on roadmap) Dependencies flumine relies on these libraries: betfairlightweight - Betfair API support tenacity - Used for connection retrying (streaming) python-json-logger - JSON logging requests - HTTP support","title":"Introduction"},{"location":"#installation","text":"$ pip install flumine flumine requires Python 3.5+","title":"installation"},{"location":"#setup","text":"Get started... import betfairlightweight from flumine import Flumine , clients trading = betfairlightweight . APIClient ( \"username\" ) client = clients . BetfairClient ( trading ) framework = Flumine ( client = client , ) Example strategy: from flumine import BaseStrategy from flumine.order.trade import Trade from flumine.order.order import LimitOrder , OrderStatus from flumine.markets.market import Market from betfairlightweight.filters import streaming_market_filter from betfairlightweight.resources import MarketBook class ExampleStrategy ( BaseStrategy ): def start ( self ) -> None : print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market : Market , market_book : MarketBook ) -> bool : # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market : Market , market_book : MarketBook ) -> None : # process marketBook object for runner in market_book . runners : if runner . status == \"ACTIVE\" and runner . last_price_traded < 1.5 : trade = Trade ( market_id = market_book . market_id , selection_id = runner . selection_id , handicap = runner . handicap , strategy = self , ) order = trade . create_order ( side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) self . place_order ( market , order ) def process_orders ( self , market : Market , orders : list ) -> None : for order in orders : if order . status == OrderStatus . EXECUTABLE : if order . size_remaining == 2.00 : self . cancel_order ( order , 0.02 ) # reduce size to 1.98 if order . order_type . persistence_type == \"LAPSE\" : self . update_order ( order , \"PERSIST\" ) if order . size_remaining > 0 : self . replace_order ( order , 1.02 ) # move strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ) ) framework . add_strategy ( strategy ) Run framework: framework . run () Danger By default flumine will try and prevent coding errors which result in flash crashes and burnt fingers but use at your own risk as per the MIT license. Recommendation is not to remove the trading controls and carry out extensive testing before executing on live markets, even then only use new strategies on an account with a small balance (transfer balance to games wallet).","title":"setup"},{"location":"#features","text":"Streaming Multiple strategies Order execution Back testing (in development) Paper trading (on roadmap) Analytics (in development) Scores / RaceCard / InPlayService (on roadmap)","title":"Features"},{"location":"#dependencies","text":"flumine relies on these libraries: betfairlightweight - Betfair API support tenacity - Used for connection retrying (streaming) python-json-logger - JSON logging requests - HTTP support","title":"Dependencies"},{"location":"advanced/","text":"Advanced Flumine The Flumine class can be adapted by overriding the following functions: _process_market_books() called on MarketBook event _process_raw_data() called on RawData event _process_market_catalogues called on MarketCatalogue event _process_current_orders called on currentOrders event _process_end_flumine() called on Flumine termination Base Strategy Parameters market_filter Streaming market filter required market_data_filter Streaming market data filter required streaming_timeout Streaming timeout, will call snap() on cache every x seconds conflate_ms Streaming conflate stream_class MarketStream or RawDataStream name Strategy name, if None will default to class name context Dictionary object where any extra data can be stored here such as triggers Functions The following functions can be overridden dependant on the strategy: add() Function called when strategy is added to framework start() Function called when framework starts check_market_book() Function called with marketBook, process_market_book is only executed if this returns True process_market_book() Processes market book updates, called on every update that is received process_raw_data() As per process_market_book but handles raw data process_race_card() In development process_orders() In development finish() Function called when framework ends Streams Market Stream Flumine handles market streams by taking the parameters provided in the strategies, a strategy will then subscribe to the stream. This means strategies can share streams reducing load or create new if they require different markets or data filter. Data Stream Similar to Market Streams but the raw streaming data is passed back, this reduces ram/CPU and allows recording of the data for future playback, see the example marketrecorder.py Historical Stream This is created on a per market basis when backtesting. Order Stream In development Custom Stream In development Trading Controls In development Client Controls Trading Controls Logging Controls Custom logging is available using the LoggingControl class, the base class creates debug logs and can be used as follows: from flumine.controls.loggingcontrols import LoggingControl control = LoggingControl () framework . add_logging_control ( control ) Tip More than one control can be added, for example a csv logger and db logger. Background Workers By default flumine adds the following workers: keep_alive : runs every 1200s to make sure the client is either logged in or kept alive poll_market_catalogue : runs every 60s to poll listMarketCatalogue endpoint Further workers can be added as per: from flumine.worker import BackgroundWorker def func ( a ): print ( a ) worker = BackgroundWorker ( interval = 10 , function = func , func_args = ( \"hello\" ,), name = \"print_a\" ) framework . add_worker ( worker ) Error Handling Logging Config hostname Used as customerStrategyRefs so that only orders created by the running instance is returned. process_id OS process id of running application. current_time Used for backtesting","title":"Advanced Usage"},{"location":"advanced/#advanced","text":"","title":"Advanced"},{"location":"advanced/#flumine","text":"The Flumine class can be adapted by overriding the following functions: _process_market_books() called on MarketBook event _process_raw_data() called on RawData event _process_market_catalogues called on MarketCatalogue event _process_current_orders called on currentOrders event _process_end_flumine() called on Flumine termination","title":"Flumine"},{"location":"advanced/#base-strategy","text":"","title":"Base Strategy"},{"location":"advanced/#parameters","text":"market_filter Streaming market filter required market_data_filter Streaming market data filter required streaming_timeout Streaming timeout, will call snap() on cache every x seconds conflate_ms Streaming conflate stream_class MarketStream or RawDataStream name Strategy name, if None will default to class name context Dictionary object where any extra data can be stored here such as triggers","title":"Parameters"},{"location":"advanced/#functions","text":"The following functions can be overridden dependant on the strategy: add() Function called when strategy is added to framework start() Function called when framework starts check_market_book() Function called with marketBook, process_market_book is only executed if this returns True process_market_book() Processes market book updates, called on every update that is received process_raw_data() As per process_market_book but handles raw data process_race_card() In development process_orders() In development finish() Function called when framework ends","title":"Functions"},{"location":"advanced/#streams","text":"","title":"Streams"},{"location":"advanced/#market-stream","text":"Flumine handles market streams by taking the parameters provided in the strategies, a strategy will then subscribe to the stream. This means strategies can share streams reducing load or create new if they require different markets or data filter.","title":"Market Stream"},{"location":"advanced/#data-stream","text":"Similar to Market Streams but the raw streaming data is passed back, this reduces ram/CPU and allows recording of the data for future playback, see the example marketrecorder.py","title":"Data Stream"},{"location":"advanced/#historical-stream","text":"This is created on a per market basis when backtesting.","title":"Historical Stream"},{"location":"advanced/#order-stream","text":"In development","title":"Order Stream"},{"location":"advanced/#custom-stream","text":"In development","title":"Custom Stream"},{"location":"advanced/#trading-controls","text":"In development","title":"Trading Controls"},{"location":"advanced/#client-controls","text":"","title":"Client Controls"},{"location":"advanced/#trading-controls_1","text":"","title":"Trading Controls"},{"location":"advanced/#logging-controls","text":"Custom logging is available using the LoggingControl class, the base class creates debug logs and can be used as follows: from flumine.controls.loggingcontrols import LoggingControl control = LoggingControl () framework . add_logging_control ( control ) Tip More than one control can be added, for example a csv logger and db logger.","title":"Logging Controls"},{"location":"advanced/#background-workers","text":"By default flumine adds the following workers: keep_alive : runs every 1200s to make sure the client is either logged in or kept alive poll_market_catalogue : runs every 60s to poll listMarketCatalogue endpoint Further workers can be added as per: from flumine.worker import BackgroundWorker def func ( a ): print ( a ) worker = BackgroundWorker ( interval = 10 , function = func , func_args = ( \"hello\" ,), name = \"print_a\" ) framework . add_worker ( worker )","title":"Background Workers"},{"location":"advanced/#error-handling","text":"","title":"Error Handling"},{"location":"advanced/#logging","text":"","title":"Logging"},{"location":"advanced/#config","text":"","title":"Config"},{"location":"advanced/#hostname","text":"Used as customerStrategyRefs so that only orders created by the running instance is returned.","title":"hostname"},{"location":"advanced/#process_id","text":"OS process id of running application.","title":"process_id"},{"location":"advanced/#current_time","text":"Used for backtesting","title":"current_time"},{"location":"design/","text":"Design Main loop Typical to most trading frameworks flumine uses an event driven design with the main thread handling these events through a FIFO queue . handles all events in order one by one runs in main Events: MARKET_CATALOGUE Betfair MarketCatalogue object MARKET_BOOK Betfair MarketBook object RAW_DATA Raw streaming data CURRENT_ORDERS Betfair CurrentOrders object CLEARED_MARKETS Betfair ClearedMarkets object CLEARED_ORDERS Betfair ClearedOrders object CLOSE_MARKET flumine Close Market update STRATEGY_RESET flumine Strategy Reset update CUSTOM_EVENT flumine Custom event update NEW_DAY flumine New Day update TERMINATOR flumine End instance update The above events are handled in the flumine class MarketBook Cycle Backtesting Backtesting is achieved by monkeypatching the datetime function utcnow(), this allows strategies to be simulated as if they were being executed in real time. Functions such as market.seconds_to_start and fillKill.seconds work as per a live execution. Streams Single stream (market) As above but 'data' (flumine listener) Order stream Future work: Custom stream Strategy Class based Subscribe to streams Single strategy subscribes to a single market stream Handles Stream reconnect Trading client login/logout Trading client keep alive Future work: Execution place/cancel/replace/update controls fillKill Market Catalogue Polling (scores/raceCard etc) CurrentOrders / ClearedOrders database connection/logging notes market middleware (analytics/logging) order middleware (controls) paper trading back testing","title":"Design"},{"location":"design/#design","text":"","title":"Design"},{"location":"design/#main-loop","text":"Typical to most trading frameworks flumine uses an event driven design with the main thread handling these events through a FIFO queue . handles all events in order one by one runs in main","title":"Main loop"},{"location":"design/#events","text":"MARKET_CATALOGUE Betfair MarketCatalogue object MARKET_BOOK Betfair MarketBook object RAW_DATA Raw streaming data CURRENT_ORDERS Betfair CurrentOrders object CLEARED_MARKETS Betfair ClearedMarkets object CLEARED_ORDERS Betfair ClearedOrders object CLOSE_MARKET flumine Close Market update STRATEGY_RESET flumine Strategy Reset update CUSTOM_EVENT flumine Custom event update NEW_DAY flumine New Day update TERMINATOR flumine End instance update The above events are handled in the flumine class","title":"Events:"},{"location":"design/#marketbook-cycle","text":"","title":"MarketBook Cycle"},{"location":"design/#backtesting","text":"Backtesting is achieved by monkeypatching the datetime function utcnow(), this allows strategies to be simulated as if they were being executed in real time. Functions such as market.seconds_to_start and fillKill.seconds work as per a live execution.","title":"Backtesting"},{"location":"design/#streams","text":"Single stream (market) As above but 'data' (flumine listener) Order stream Future work: Custom stream","title":"Streams"},{"location":"design/#strategy","text":"Class based Subscribe to streams Single strategy subscribes to a single market stream","title":"Strategy"},{"location":"design/#handles","text":"Stream reconnect Trading client login/logout Trading client keep alive Future work: Execution place/cancel/replace/update controls fillKill Market Catalogue Polling (scores/raceCard etc) CurrentOrders / ClearedOrders database connection/logging","title":"Handles"},{"location":"design/#notes","text":"market middleware (analytics/logging) order middleware (controls) paper trading back testing","title":"notes"},{"location":"execution/","text":"Clients / Execution Live - Betfair When using the BetfairClient flumine will default to using the integrated BetfairExecution class, this class can handle: placeOrders cancelOrders updateOrders replaceOrders Simulated The BacktestClient will use the SimulatedExecution class and can be used for backtesting or paper trading where order matching is handled locally. In development. Custom Custom execution can be applied by creating your own client/overriding the add_execution function like so: from flumine.execution.baseexecution import BaseExecution from flumine.clients.baseclient import BaseClient class PrinterExecution ( BaseExecution ): def execute_place ( self , order_package , http_session ): print ( \"execute_place\" ) def execute_cancel ( self , order_package , http_session ): print ( \"execute_cancel\" ) def execute_update ( self , order_package , http_session ): print ( \"execute_update\" ) def execute_replace ( self , order_package , http_session ): print ( \"execute_replace\" ) class PrinterClient ( BaseClient ): def login ( self ): return def keep_alive ( self ): return def logout ( self ): return def add_execution ( self , flumine ): self . execution = PrinterExecution ( flumine ) @property def min_bet_size ( self ): return 2.0 @property def min_bet_payout ( self ): return 10.0 @property def min_bsp_liability ( self ): return 10.0 client = PrinterClient () Tip This can be used to handle other exchanges (betdaq) or API's that flumine cannot currently handle.","title":"Clients / Execution"},{"location":"execution/#clients-execution","text":"","title":"Clients / Execution"},{"location":"execution/#live-betfair","text":"When using the BetfairClient flumine will default to using the integrated BetfairExecution class, this class can handle: placeOrders cancelOrders updateOrders replaceOrders","title":"Live - Betfair"},{"location":"execution/#simulated","text":"The BacktestClient will use the SimulatedExecution class and can be used for backtesting or paper trading where order matching is handled locally. In development.","title":"Simulated"},{"location":"execution/#custom","text":"Custom execution can be applied by creating your own client/overriding the add_execution function like so: from flumine.execution.baseexecution import BaseExecution from flumine.clients.baseclient import BaseClient class PrinterExecution ( BaseExecution ): def execute_place ( self , order_package , http_session ): print ( \"execute_place\" ) def execute_cancel ( self , order_package , http_session ): print ( \"execute_cancel\" ) def execute_update ( self , order_package , http_session ): print ( \"execute_update\" ) def execute_replace ( self , order_package , http_session ): print ( \"execute_replace\" ) class PrinterClient ( BaseClient ): def login ( self ): return def keep_alive ( self ): return def logout ( self ): return def add_execution ( self , flumine ): self . execution = PrinterExecution ( flumine ) @property def min_bet_size ( self ): return 2.0 @property def min_bet_payout ( self ): return 10.0 @property def min_bsp_liability ( self ): return 10.0 client = PrinterClient () Tip This can be used to handle other exchanges (betdaq) or API's that flumine cannot currently handle.","title":"Custom"},{"location":"help/","text":"Help Please try the following channels for any support: Betfair Developer Support Slack Group for any help in using the library API Status if things don't seem to be working","title":"Help"},{"location":"help/#help","text":"Please try the following channels for any support: Betfair Developer Support Slack Group for any help in using the library API Status if things don't seem to be working","title":"Help"},{"location":"markets/","text":"Markets Market Within markets you have market objects which contains current up to date market data. from flumine.order.trade import Trade from flumine.order.ordertype import LimitOrder market Middleware In development Analytics / historical tick data","title":"Markets"},{"location":"markets/#markets","text":"","title":"Markets"},{"location":"markets/#market","text":"Within markets you have market objects which contains current up to date market data. from flumine.order.trade import Trade from flumine.order.ordertype import LimitOrder market","title":"Market"},{"location":"markets/#middleware","text":"In development Analytics / historical tick data","title":"Middleware"},{"location":"quickstart/","text":"QuickStart Live Tip flumine uses betfairlightweight for communicating with the Betfair API, please see docs for how to use/setup before proceeding. First, start by importing flumine/bflw and creating a trading and framework client: import betfairlightweight from flumine import Flumine , clients trading = betfairlightweight . APIClient ( \"username\" ) client = clients . BetfairClient ( trading ) framework = Flumine ( client = client , ) Note flumine will handle login, logout and keep alive whilst the framework is running. A strategy can now be created by using the BaseStrategy class: from flumine import BaseStrategy class ExampleStrategy ( BaseStrategy ): def start ( self ): # subscribe to streams print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market , market_book ): # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market , market_book ): # process marketBook object print ( market_book . status ) This strategy can now be initiated with the market and data filter before being added to the framework: from betfairlightweight.filters import ( streaming_market_filter , streaming_market_data_filter , ) strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), market_data_filter = streaming_market_data_filter ( fields = [ \"EX_ALL_OFFERS\" ]) ) flumine . add_strategy ( strategy ) The framework can now be started: framework . run () Stream class By default the stream class will be a MarketStream which provides a MarketBook python object, if collecting data this can be changed to a DataStream class however process_raw_data will be called and not process_market_book: from flumine import BaseStrategy from flumine.streams.datastream import DataStream class ExampleDataStrategy ( BaseStrategy ): def process_raw_data ( self , publish_time , data ): print ( publish_time , data ) strategy = ExampleDataStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), stream_class = DataStream ) flumine . add_strategy ( strategy ) Backtesting Flumine can be used to backtest strategies using the following code: from flumine import FlumineBacktest , clients client = clients . BacktestClient () framework = FlumineBacktest ( client = client ) strategy = ExampleStrategy ( market_filter = { \"markets\" : [ \"/tmp/marketdata/1.170212754\" ]} ) framework . add_strategy ( strategy ) framework . run () Note the use of market filter to pass the file directories. Tip Multiple strategies and markets can be passed, flumine will pass the MarketBooks to the correct strategy via its subscription.","title":"QuickStart"},{"location":"quickstart/#quickstart","text":"","title":"QuickStart"},{"location":"quickstart/#live","text":"Tip flumine uses betfairlightweight for communicating with the Betfair API, please see docs for how to use/setup before proceeding. First, start by importing flumine/bflw and creating a trading and framework client: import betfairlightweight from flumine import Flumine , clients trading = betfairlightweight . APIClient ( \"username\" ) client = clients . BetfairClient ( trading ) framework = Flumine ( client = client , ) Note flumine will handle login, logout and keep alive whilst the framework is running. A strategy can now be created by using the BaseStrategy class: from flumine import BaseStrategy class ExampleStrategy ( BaseStrategy ): def start ( self ): # subscribe to streams print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market , market_book ): # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market , market_book ): # process marketBook object print ( market_book . status ) This strategy can now be initiated with the market and data filter before being added to the framework: from betfairlightweight.filters import ( streaming_market_filter , streaming_market_data_filter , ) strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), market_data_filter = streaming_market_data_filter ( fields = [ \"EX_ALL_OFFERS\" ]) ) flumine . add_strategy ( strategy ) The framework can now be started: framework . run ()","title":"Live"},{"location":"quickstart/#stream-class","text":"By default the stream class will be a MarketStream which provides a MarketBook python object, if collecting data this can be changed to a DataStream class however process_raw_data will be called and not process_market_book: from flumine import BaseStrategy from flumine.streams.datastream import DataStream class ExampleDataStrategy ( BaseStrategy ): def process_raw_data ( self , publish_time , data ): print ( publish_time , data ) strategy = ExampleDataStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), stream_class = DataStream ) flumine . add_strategy ( strategy )","title":"Stream class"},{"location":"quickstart/#backtesting","text":"Flumine can be used to backtest strategies using the following code: from flumine import FlumineBacktest , clients client = clients . BacktestClient () framework = FlumineBacktest ( client = client ) strategy = ExampleStrategy ( market_filter = { \"markets\" : [ \"/tmp/marketdata/1.170212754\" ]} ) framework . add_strategy ( strategy ) framework . run () Note the use of market filter to pass the file directories. Tip Multiple strategies and markets can be passed, flumine will pass the MarketBooks to the correct strategy via its subscription.","title":"Backtesting"},{"location":"trades/","text":"Trades / Orders Trade A trade object is used to handle order execution. from flumine.order.trade import Trade from flumine.order.ordertype import LimitOrder trade = Trade ( market_id = \"1.2345678\" , selection_id = 123456 , handicap = 1.0 , strategy = strategy ) trade . orders # [] trade . status # todo order = trade . create_order ( side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) trade . orders # [<BetfairOrder>] Extras include: offset orders desc example fill kill greening custom You can create your own trade classes and then handle the logic within the strategy.process_orders function. Order Order objects store all order data locally allowing trade logic to be applied. from flumine.order.order import BetfairOrder , LimitOrder order = BetfairOrder ( trade = trade , side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) order . status # OrderStatus.PENDING order . executable () order . execution_complete ()","title":"Trades / Orders"},{"location":"trades/#trades-orders","text":"","title":"Trades / Orders"},{"location":"trades/#trade","text":"A trade object is used to handle order execution. from flumine.order.trade import Trade from flumine.order.ordertype import LimitOrder trade = Trade ( market_id = \"1.2345678\" , selection_id = 123456 , handicap = 1.0 , strategy = strategy ) trade . orders # [] trade . status # todo order = trade . create_order ( side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) trade . orders # [<BetfairOrder>] Extras include:","title":"Trade"},{"location":"trades/#offset-orders","text":"desc example","title":"offset orders"},{"location":"trades/#fill-kill","text":"","title":"fill kill"},{"location":"trades/#greening","text":"","title":"greening"},{"location":"trades/#custom","text":"You can create your own trade classes and then handle the logic within the strategy.process_orders function.","title":"custom"},{"location":"trades/#order","text":"Order objects store all order data locally allowing trade logic to be applied. from flumine.order.order import BetfairOrder , LimitOrder order = BetfairOrder ( trade = trade , side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) order . status # OrderStatus.PENDING order . executable () order . execution_complete ()","title":"Order"}]}